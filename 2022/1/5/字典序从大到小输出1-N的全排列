#include<iostream>
using namespace std;
int a[100];

void dfs(int cur,int n)//cur表示目前正在填的数，n表示总共要填的数 
{
    if(cur==n)//递归边界，说明填完了 
    {
        for(int i=0;i<n;i++)//一个一个的输出 
		{
			printf("%d",a[i]);	
		}
		printf("\n");
    }
    
    for(int i=1;i<=n;i++)//把数字1-n填入 
    {
        int ok=1;
        for(int j=0;j<cur;j++)//遍历目前a数组里面的元素，判断当前这个数有没有填过（用过） 
        {
            if(a[j]==i) ok=0;
        }
        if(ok==1)
        {
            a[cur]=i;//没有填过就填 ，把它放在a数组的最后 
            dfs(cur+1,n);//再排A数组元素里面的第cur+1个位置 （这里就不需要设置撤销的动作了～反正每次进来都会判断数字有没有填过） 
        }
    }
}

void dfs1(int cur,int n)//cur表示目前正在填的数，n表示总共要填的数 
{
    if(cur==n)//递归边界，说明填完了 
    {
        for(int i=0;i<n;i++)//一个一个的输出 
		{
			printf("%d",a[i]);	
		}
		printf("\n");
    }
    
    for(int i=n;i>0;i--)//把数字1-n填入 
    {
        int ok=1;
        for(int j=0;j<cur;j++)//遍历目前a数组里面的元素，判断当前这个数有没有填过（用过） 
        {
            if(a[j]==i) ok=0;
        }
        if(ok==1)
        {
            a[cur]=i;//没有填过就填 ，把它放在a数组的最后 
            dfs1(cur+1,n);//再排A数组元素里面的第cur+1个位置 （这里就不需要设置撤销的动作了～反正每次进来都会判断数字有没有填过） 
        }
    }
}


int main()
{
	int n;
   	while(scanf("%d",&n)!=EOF)
   {
   	dfs(0,n);
	 dfs1(0,n);  
	printf("\n");
   	
   }
    
    return 0;
}
